

/**
 * Plugin: YTMP3
 * Type: ESM
 * Command: .ytmp3 <url>
 */

import SaveTube from '../Library/savetube.js'

const ytdl = new SaveTube()

async function downloadMp3(url) {
  const res = await ytdl.download(url, 'mp3')
  if (!res.status) {
    throw new Error(res.msg || res.error || 'Gagal download')
  }
  return res
}

async function handler(m, { text, usedPrefix, command, sock }) {
  if (!text) {
    return m.reply(
      `❌ Masukkan URL YouTube\n\nContoh:\n${usedPrefix + command} https://youtu.be/xxxx`
    )
  }

  try {
    await m.reply('⏳ Mengunduh audio, mohon tunggu...')

    const data = await downloadMp3(text)

    await sock.sendMessage(
      m.chat,
      {
        audio: { url: data.dl },
        mimetype: 'audio/mpeg',
        fileName: `${data.title}.mp3`,
        contextInfo: {
          externalAdReply: {
            title: data.title,
            body: `Durasi: ${data.duration}`,
            thumbnailUrl: data.thumb,
            mediaType: 1,
            renderLargerThumbnail: true
          }
        }
      },
      { quoted: m }
    )

  } catch (err) {
    console.error(err)
    await m.reply(`❌ Error: ${err.message}`)
  }
}

handler.help = ['ytmp3 <url>']
handler.tags = ['downloader']
handler.command = /^(ytmp3)$/i

export default handler


//###########[ SAVETUBE.JS ]#############
const crypto = require("crypto")
const axios = require("axios")

class savetube {
  constructor() {
    this.ky = 'C5D58EF67A7584E4A29F6C35BBC4EB12'
    this.fmt = ['144', '240', '360', '480', '720', '1080', 'mp3']
    this.m = /^((?:https?:)?\/\/)?((?:www|m|music)\.)?(?:youtube\.com|youtu\.be)\/(?:watch\?v=)?(?:embed\/)?(?:v\/)?(?:shorts\/)?([a-zA-Z0-9_-]{11})/
    this.is = axios.create({
      headers: {
        'content-type': 'application/json',
        'origin': 'https://yt.savetube.me',
        'user-agent': 'Mozilla/5.0 (Android 15; Mobile; SM-F958; rv:130.0) Gecko/130.0 Firefox/130.0'
      }
    })
  }

  async decrypt(enc) {
    try {
      const sr = Buffer.from(enc, 'base64')
      const ky = Buffer.from(this.ky, 'hex')
      const iv = sr.slice(0, 16)
      const dt = sr.slice(16)
      const dc = crypto.createDecipheriv('aes-128-cbc', ky, iv)
      const res = Buffer.concat([dc.update(dt), dc.final()])
      return JSON.parse(res.toString())
    } catch (e) {
      throw new Error(`Error while decrypting data: ${e.message}`)
    }
  }

  async getCdn() {
    const response = await this.is.get("https://media.savetube.vip/api/random-cdn")
    if (!response.data) return { status: false }
    return {
      status: true,
      data: response.data.cdn
    }
  }

  async download(url, format = 'mp3') {
    const id = url.match(this.m)?.[3]
    if (!id) {
      return { status: false, msg: "ID cannot be extracted from url" }
    }

    if (!this.fmt.includes(format)) {
      return { status: false, msg: "Formats not found", list: this.fmt }
    }

    try {
      const cdn = await this.getCdn()
      if (!cdn.status) return cdn

      const info = await this.is.post(`https://${cdn.data}/v2/info`, {
        url: `https://www.youtube.com/watch?v=${id}`
      })

      const dec = await this.decrypt(info.data.data)

      const dl = await this.is.post(`https://${cdn.data}/download`, {
        id,
        downloadType: format === 'mp3' ? 'audio' : 'video',
        quality: format === 'mp3' ? '128' : format,
        key: dec.key
      })

      return {
        status: true,
        title: dec.title,
        format,
        thumb: dec.thumbnail || `https://i.ytimg.com/vi/${id}/hqdefault.jpg`,
        duration: dec.duration,
        cached: dec.fromCache,
        dl: dl.data.data.downloadUrl
      }
    } catch (e) {
      return { status: false, error: e.message }
    }
  }
}

module.exports = savetube